import { NextRequest, NextResponse } from 'next/server'
import { verifyToken } from './lib/auth/jwt'
import type { AuthTokens, User } from './app/types/global'

// 定义路由保护规则 - 只有登录相关页面是公开的
const PUBLIC_PATHS = [
  '/login',
  '/register',
  '/auth',
]

const API_PUBLIC_PATHS = [
  '/api/auth/login',
  '/api/auth/register',
  '/api/auth/refresh',
  '/api/version',
  '/api/models',
  '/api/test-provider',
]

const PROTECTED_PATHS = [
  '/admin',
  '/cicd',
  '/config',
  '/monitor',
  '/servers',
  '/tools',
  '/ai',
]

const API_PROTECTED_PATHS = [
  '/api/auth/logout',
  '/api/auth/verify',
  '/api/auth/profile',
  '/api/gemini',
  '/api/system',
]

// 角色权限映射
const ROLE_PATHS = {
  admin: ['/admin', '/config', '/monitor', '/servers', '/tools', '/ai', '/cicd'],
  manager: ['/monitor', '/servers', '/tools', '/ai', '/cicd'],
  developer: ['/tools', '/ai', '/cicd'],
  viewer: ['/monitor', '/ai'],
}

/**
 * 检查路径是否为公开路径
 */
function isPublicPath(pathname: string): boolean {
  return PUBLIC_PATHS.some(path => 
    pathname === path || pathname.startsWith(`${path}/`)
  ) || API_PUBLIC_PATHS.some(path => 
    pathname === path || pathname.startsWith(`${path}/`)
  )
}

/**
 * 检查路径是否需要认证
 */
function isProtectedPath(pathname: string): boolean {
  return PROTECTED_PATHS.some(path => 
    pathname.startsWith(`${path}`)
  ) || API_PROTECTED_PATHS.some(path => 
    pathname.startsWith(`${path}`)
  )
}

/**
 * 检查用户是否有权限访问特定路径
 */
function hasPermissionForPath(pathname: string, userRole: string): boolean {
  const allowedPaths = ROLE_PATHS[userRole as keyof typeof ROLE_PATHS] || []
  return allowedPaths.some(path => pathname.startsWith(path))
}

/**
 * 从请求中提取认证Token
 */
function extractTokenFromRequest(request: NextRequest): string | null {
  // 尝试从Authorization header获取
  const authHeader = request.headers.get('authorization')
  if (authHeader && authHeader.startsWith('Bearer ')) {
    return authHeader.substring(7)
  }

  // 尝试从cookie获取
  const token = request.cookies.get('accessToken')?.value
  if (token) {
    return token
  }

  return null
}

/**
 * 创建重定向响应
 */
function createRedirectResponse(request: NextRequest, redirectPath: string) {
  const url = request.nextUrl.clone()
  
  // 保存原始请求URL作为返回地址
  const returnUrl = encodeURIComponent(request.nextUrl.pathname + request.nextUrl.search)
  
  url.pathname = redirectPath
  if (redirectPath === '/login') {
    url.search = `?returnUrl=${returnUrl}`
  } else {
    url.search = ''
  }
  
  return NextResponse.redirect(url)
}

/**
 * 创建API错误响应
 */
function createApiErrorResponse(status: number, message: string) {
  return NextResponse.json(
    {
      success: false,
      error: message,
      code: status === 401 ? 'UNAUTHORIZED' : 'FORBIDDEN'
    },
    { status }
  )
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // 跳过静态资源和内部Next.js路径
  if (
    pathname.startsWith('/_next/') ||
    pathname.startsWith('/favicon.ico') ||
    pathname.includes('.')
  ) {
    return NextResponse.next()
  }

  // 公开路径直接通过
  if (isPublicPath(pathname)) {
    return NextResponse.next()
  }

  // 检查是否为需要保护的路径
  if (!isProtectedPath(pathname)) {
    return NextResponse.next()
  }

  // 提取认证Token
  const token = extractTokenFromRequest(request)
  
  if (!token) {
    // 未认证用户处理
    if (pathname.startsWith('/api/')) {
      return createApiErrorResponse(401, 'Authentication required')
    }
    return createRedirectResponse(request, '/login')
  }

  try {
    // 验证Token并获取用户信息
    const payload = await verifyToken(token)
    
    if (!payload || !payload.userId) {
      throw new Error('Invalid token payload')
    }

    // 检查用户角色权限
    const userRole = payload.role || 'viewer'
    
    if (!hasPermissionForPath(pathname, userRole)) {
      // 权限不足处理
      if (pathname.startsWith('/api/')) {
        return createApiErrorResponse(403, 'Insufficient permissions')
      }
      return createRedirectResponse(request, '/auth/403')
    }

    // 添加用户信息到请求头，供后续处理使用
    const requestHeaders = new Headers(request.headers)
    requestHeaders.set('x-user-id', payload.userId)
    requestHeaders.set('x-user-role', userRole)
    requestHeaders.set('x-user-email', payload.email || '')

    return NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    })

  } catch (error) {
    console.error('Middleware auth error:', error)
    
    // Token无效或过期
    if (pathname.startsWith('/api/')) {
      return createApiErrorResponse(401, 'Invalid or expired token')
    }
    
    // 清除无效cookie并重定向到登录页
    const response = createRedirectResponse(request, '/login')
    response.cookies.delete('accessToken')
    response.cookies.delete('refreshToken')
    
    return response
  }
}

// 配置中间件匹配规则
export const config = {
  matcher: [
    /*
     * 匹配所有路径除了:
     * 1. /api/auth/login, /api/auth/register (登录注册)
     * 2. /_next/static (静态文件)
     * 3. /_next/image (图像优化)
     * 4. /favicon.ico, /sitemap.xml 等静态资源
     */
    '/((?!_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
  ],
} 