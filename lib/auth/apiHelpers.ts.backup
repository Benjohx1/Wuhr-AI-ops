// 认证API辅助工具
import { NextRequest, NextResponse } from 'next/server'
import { ZodSchema, ZodError } from 'zod'
import { verifyToken, createTokens } from './jwt'
import { PostgresStorageProvider } from '../storage/PostgresStorageProvider'
import { ApiResponse, AuthError } from '../../app/types/api'

// 创建数据库实例
const dbProvider = new PostgresStorageProvider()

// 扩展数据库实例，添加Prisma客户端访问
export const db = {
  ...dbProvider,
  prisma: null as any, // 将在initialize时设置
}

// 标准API响应格式
export function createResponse<T>(
  success: boolean,
  data?: T,
  error?: string,
  details?: string,
  status: number = 200
): NextResponse {
  const response: ApiResponse<T> = {
    success,
    data,
    error,
    details,
    timestamp: new Date().toISOString()
  }

  return NextResponse.json(response, { status })
}

// 成功响应
export function successResponse<T>(data: T, status: number = 200): NextResponse {
  return createResponse(true, data, undefined, undefined, status)
}

// 错误响应
export function errorResponse(
  error: string,
  details?: string,
  status: number = 400
): NextResponse {
  return createResponse(false, undefined, error, details, status)
}

// 服务器错误响应
export function serverErrorResponse(error: any): NextResponse {
  console.error('API错误:', error)
  return createResponse(
    false,
    undefined,
    '服务器内部错误',
    error instanceof Error ? error.message : 'Unknown error',
    500
  )
}

// 请求验证中间件
export async function validateRequest<T>(
  request: NextRequest,
  schema: ZodSchema<T>
): Promise<{ success: true; data: T } | { success: false; response: NextResponse }> {
  try {
    const body = await request.json()
    const validatedData = schema.parse(body)
    return { success: true, data: validatedData }
  } catch (error) {
    if (error instanceof ZodError) {
      const errors = error.errors.map(err => ({
        field: err.path.join('.'),
        message: err.message
      }))
      
      return {
        success: false,
        response: errorResponse(
          '请求参数验证失败',
          JSON.stringify(errors),
          400
        )
      }
    }
    
    return {
      success: false,
      response: errorResponse('请求格式错误', undefined, 400)
    }
  }
}

// 认证中间件
export async function requireAuth(
  request: NextRequest
): Promise<
  { success: true; user: any } | 
  { success: false; response: NextResponse }
> {
  try {
    const authHeader = request.headers.get('authorization')
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return {
        success: false,
        response: errorResponse('缺少认证令牌', undefined, 401)
      }
    }

    const token = authHeader.substring(7)
    const decoded = await verifyToken(token, 'access')
    
    if (!decoded) {
      return {
        success: false,
        response: errorResponse('认证令牌无效', undefined, 401)
      }
    }

    // 获取用户信息
    const user = await dbProvider.users.findById(decoded.userId)
    if (!user || !user.isActive) {
      return {
        success: false,
        response: errorResponse('用户不存在或已被禁用', undefined, 401)
      }
    }

    return { success: true, user }
  } catch (error) {
    console.error('认证验证失败:', error)
    return {
      success: false,
      response: errorResponse('认证验证失败', undefined, 401)
    }
  }
}

// 权限检查中间件
export async function requirePermission(
  request: NextRequest,
  requiredPermission: string
): Promise<
  { success: true; user: any } | 
  { success: false; response: NextResponse }
> {
  const authResult = await requireAuth(request)
  
  if (!authResult.success) {
    return authResult
  }

  const { user } = authResult
  
  if (!user.permissions.includes(requiredPermission) && user.role !== 'admin') {
    return {
      success: false,
      response: errorResponse('权限不足', `需要权限: ${requiredPermission}`, 403)
    }
  }

  return { success: true, user }
}

// 简单的内存频率限制器
class RateLimiter {
  private requests = new Map<string, number[]>()
  private limit: number
  private windowMs: number

  constructor(limit: number = 10, windowMs: number = 60000) {
    this.limit = limit
    this.windowMs = windowMs
  }

  check(key: string): boolean {
    const now = Date.now()
    const windowStart = now - this.windowMs

    if (!this.requests.has(key)) {
      this.requests.set(key, [now])
      return true
    }

    const requestTimes = this.requests.get(key)!
    
    // 清理过期请求
    const validRequests = requestTimes.filter(time => time > windowStart)
    
    if (validRequests.length >= this.limit) {
      return false
    }

    validRequests.push(now)
    this.requests.set(key, validRequests)
    return true
  }

  reset(key: string) {
    this.requests.delete(key)
  }
}

// 全局频率限制器实例
export const authRateLimiter = new RateLimiter(5, 60000) // 5次/分钟
export const generalRateLimiter = new RateLimiter(30, 60000) // 30次/分钟

// 频率限制中间件
export function rateLimit(
  limiter: RateLimiter,
  getKey: (request: NextRequest) => string = (req) => req.ip || 'unknown'
) {
  return (request: NextRequest): NextResponse | null => {
    const key = getKey(request)
    
    if (!limiter.check(key)) {
      return errorResponse(
        '请求过于频繁',
        '请稍后再试',
        429
      )
    }

    return null
  }
}

// 记录认证日志
export async function logAuthEvent(
  action: 'login' | 'logout' | 'register' | 'password_change' | 'failed_login' | 'token_refresh',
  request: NextRequest,
  userId?: string,
  username?: string,
  success: boolean = true,
  details?: string
) {
  try {
    await db.authLogs.log({
      userId,
      username,
      action,
      success,
      ipAddress: request.ip || request.headers.get('x-forwarded-for') || 'unknown',
      userAgent: request.headers.get('user-agent') || 'unknown',
      details
    })
  } catch (error) {
    console.error('记录认证日志失败:', error)
  }
}

// 生成安全的错误消息（避免信息泄露）
export function createAuthError(
  code: string,
  message: string,
  field?: string
): AuthError {
  return { code, message, field }
}

// 常见认证错误
export const AUTH_ERRORS = {
  INVALID_CREDENTIALS: createAuthError('INVALID_CREDENTIALS', '用户名或密码错误'),
  USER_NOT_FOUND: createAuthError('USER_NOT_FOUND', '用户不存在'),
  USER_INACTIVE: createAuthError('USER_INACTIVE', '用户账户已被禁用'),
  USERNAME_EXISTS: createAuthError('USERNAME_EXISTS', '用户名已存在', 'username'),
  EMAIL_EXISTS: createAuthError('EMAIL_EXISTS', '邮箱已存在', 'email'),
  WEAK_PASSWORD: createAuthError('WEAK_PASSWORD', '密码强度不足', 'password'),
  PASSWORDS_MISMATCH: createAuthError('PASSWORDS_MISMATCH', '两次输入的密码不一致', 'confirmPassword'),
  INVALID_TOKEN: createAuthError('INVALID_TOKEN', '无效的认证令牌'),
  TOKEN_EXPIRED: createAuthError('TOKEN_EXPIRED', '认证令牌已过期'),
  INSUFFICIENT_PERMISSIONS: createAuthError('INSUFFICIENT_PERMISSIONS', '权限不足'),
  RATE_LIMITED: createAuthError('RATE_LIMITED', '请求过于频繁，请稍后再试'),
} as const

// 数据库初始化助手
export async function ensureDbInitialized() {
  try {
    // 初始化数据库连接
    await dbProvider.initialize()
    
    // 设置Prisma客户端引用
    const { getPrismaClient } = await import('../config/database')
    db.prisma = await getPrismaClient()
    
    const userCount = await dbProvider.users.count()
    if (userCount === 0) {
      console.log('初始化认证数据库...')
      // 数据库已在initialize()中创建默认数据
    }
  } catch (error) {
    console.error('数据库初始化失败:', error)
    throw error
  }
}

// 导出数据库实例
export { db } 